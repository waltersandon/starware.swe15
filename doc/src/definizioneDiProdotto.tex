\documentclass[12pt,a4paper]{article}
\input{../style/stile.sty}
\input{../tex/glossario.tex}

%Titolo documento
\newcommand{\titoloDocumento}{Definizione di prodotto}

%Prima data di creazione del documento
\newcommand{\dataCreazione}{01 Marzo 2016}

%Inserite la versione attuale del documento
\newcommand{\versione}{2.0.0}

%Stato in cui si trova il documento: Formale solo all'atto di consegna
\newcommand{\stato}{Formale}

%Uso del documento
\newcommand{\uso}{Esterno}

\rhead{\titoloDocumento}
\lfoot{Versione: \versione}
\title{\titoloDocumento}

\begin{document}
\begin{titlepage}
	\begin{center}
		\intestazione{\titoloDocumento}
		
		\begin{table}[h]
			\begin{center}
				\begin{tabular}{r | l}
					\multicolumn{2}{c}{\textbf{Informazioni sul documento}}\\
					\midrule
					\textbf{Nome Documento} & \titoloDocumento \\
					\textbf{Versione} & \versione \\
					\textbf{Stato} & \emph{\stato} \\
					\textbf{Uso} & \emph{\uso} \\
					\textbf{Data Creazione} & \dataCreazione \\
					\textbf{Data Ultima Modifica} & \today \\
					\textbf{Redazione} & Tutto il gruppo \nomeGruppo \\
					\textbf{Verifica} & \AB\\
					\  &  \WS\\
					\  &  \AVE\\
					\  &  \AVI\\
					\  &  \IB\\
					\  &  \NDC\\
                    \textbf{Approvazione} &  \TP{}\\
					\textbf{Lista Distribuzione} & \nomeGruppo \\
					\  & \Vardanega \\
					\  & \Cardin \\
					\  & Il proponente \Zucchetti \\
					
				\end{tabular}
			\end{center}
		\end{table}
		
	\end{center}
\end{titlepage}

\newpage
\Large{\textbf{Registro delle modifiche}}\\
\normalsize

\begin{center}
	\begin{longtable}[H]{p{0.12\textwidth} p{0.2\textwidth} p{0.18\textwidth} p{0.39\textwidth}}
		\toprule
		\textbf{Versione}	&	\textbf{Autore}	&	\textbf{Data}	&	\textbf{Descrizione}\\*
		\midrule
		\midrule
		2.0.0 & \AVE & 2016-05-14 & Approvazione \\*
		\midrule
		1.1.1 & \WS & 2016-05-14 & Verifica \\*
		\midrule
		1.1.0 & \NDC & 2016-05-13 & Verifica \\*
		\midrule
		1.0.11 & \TODO{} & 2016-05-11 &  \\*
		\midrule
		1.0.11 & \TODO{} & 2016-05-10 &  \\*
		\midrule
		1.0.10 & \TODO{} & 2016-05-08 & Controllo, ampliamento ed aggiunta diagrammi di sequenza \\*
		\midrule
		1.0.9 & \TODO{} & 2016-05-05 & Rimozione analisi database NoSql in quanto trattato nel capitolo di MongoDB \\*
		\midrule
		1.0.8 & \TODO{} & 2016-05-05 & Aggiunta analisi criticità delle tenologie adottate \\*
		\midrule
		1.0.7 & \TP{} & 2016-05-03 & Aggiunte note su sicurezza e autenticazione dell'API REST \\*
		\midrule
		1.0.6 & \TP{} & 2016-04-28 & All'interno dell'API REST sono stati semplificati i riferimenti ad oggetti di ritorno rimuovendo la notazione \texttt{\{ href: ".." \}} in favore di una semplice stringa contenente l'ID dell'oggetto \\*
		\midrule
		1.0.5 & \TP{} & 2016-04-24 & Il model \texttt{User} ha un attributo \texttt{isActive} che definisce se non è stato cancellato nel sistema \\*
		\midrule
		1.0.4 & \TP{} & 2016-04-24 & Aggiunta della restituzione della risorsa alla sua creazione nell'API REST \\*
		\midrule
		\midrule
		1.0.3 & \TP{} & 2016-04-24 & Gli ID degli oggetti sono nell'attributo \texttt{\_id} non più in \texttt{id} \\*
		\midrule
		1.0.2 & \TP{} & 2016-04-24 & Semplificazione riferimenti ad altri oggetti nell'API REST
			rimuovendo la notazione \texttt{\{ id: ".." \}} in favore della stringa rappresentate l'ID dell'oggetto
			riferito \\*
		\midrule
		1.0.1 & \TP{} & 2016-04-23 & Rimozione metodo \texttt{checkUniqueUserName} della classe
			\texttt{UserCheck} \\*
		\midrule
		1.0.0 & \TP{} & 2016-04-10 & Approvazione \\*
		\midrule
		0.1.5 & \NDC{} & 2016-04-08 & Verifica \\*
		\midrule
		0.1.4 & \WS{} & 2016-04-07 & Verifica \\*
		\midrule
		0.1.3 & \AVE{} & 2016-04-07 & Verifica \\*
		\midrule
		0.1.2 & \AVI{} & 2016-04-06 & Verifica \\*
		\midrule
		0.1.1 & \AB{} & 2016-04-06 & Verifica \\*
		\midrule
		0.1.0 & \IB{} & 2016-04-05 & Verifica \\*
		\midrule
		0.0.18 & \NDC{} & 2016-04-05 & Aggiunti diagrammi di sequenza \\*
		\midrule
		0.0.17 & \IB{} & 2016-04-05 & Aggiunta classi client \\*
		\midrule
		0.0.16 & \WS{} & 2016-04-01 & Aggiunta classi client \\*
		\midrule
		0.0.15 & \AB{} & 2016-03-25 & Aggiunta classi client \\*
		\midrule
		0.0.14 & \NDC{} & 2016-03-22 & Aggiunta classi client \\*
		\midrule
		0.0.13 & \NDC{} & 2016-03-22 & Aggiunta package client \\*
		\midrule
		0.0.12 & \AVE{} & 2016-03-20 & Aggiunta classi server \\*
		\midrule
		0.0.11 & \AVI{} & 2016-03-18 & Aggiunta classi server \\*
		\midrule
		0.0.10 & \TP{} & 2016-03-16 & Aggiunta classi server \\*
		\midrule
		0.0.9 & \TP{} & 2016-03-16 & Aggiunta package server \\*
        \midrule
        0.0.8 & \NDC{} & 2016-03-15 & Definizione struttura del documento e aggiunta
            degli standard di progetto \\*
		\midrule
		0.0.7 & \AVE{} & 2016-03-12 & Aggiunta descrizioni tecnologie HTML5, CSS3, Javascript, 
            Express, Bootstrap e Angular \\*
		\midrule
		0.0.6 & \AVE{} & 2016-03-11 & Aggiunte descrizioni tecnologie Node.js, NoSQL, Mongoose, MongoDB \\*
		\midrule
		0.0.5 & \AVE{} & 2016-03-011 & Modifica descrizioni tabella REST API \\*
		\midrule
		0.0.4 & \TP{} & 2016-03-09 &  Aggiunta descrizioni tabella REST API \\*
		\midrule
		0.0.3 & \TP{} & 2016-03-07 &  Modifica struttura tabella REST API \\*
		\midrule
		0.0.2 & \AVI{} & 2016-03-05 &  Aggiunta descrizioni tabella REST API \\*
		\midrule
		0.0.1 & \NDC{} & 2016-03-03 &  Creazione tabella REST API \\*
		\midrule
		0.0.0 & \NDC{} & 2016-03-02 &  Creazione documento \\*
		\bottomrule
		\caption{Versionamento del documento}
		\label{tabVers1} 
	\end{longtable}
\end{center}

\newpage
\tableofcontents
\newpage
\listoftables
\listoffigures
\newpage

\section{Introduzione}	\label{intro}
\subsection{Scopo}
Lo scopo di questo documento è di definire nel dettaglio l'architettura del sistema sviluppato, fornendo una struttura completa ai programmatori per l'attività di codifica.

\subsection{Descrizione}
Il documento presenterà le tecnologie e gli standard scelti per il sviluppo del \mgls{software}. Verranno inoltre specificati nel dettaglio i \mgls{package} e le classi che verranno poi codificati. Successivamente verranno specificati i diagrammi di sequenza delle operazioni principali fornite dall'applicazione. E infine verrà specifica l'interfaccia REST.

\subsection{Descrizione Prodotto}
\descrizioneProdotto

\subsection{Glossario}
\glossarioPrint

\subsection{Riferimenti}

\subsubsection{Normativi}
\begin{itemize}
    \item \NdP{}: \textit{NormeDiProgetto\_v3.0.0};
    \item \AdR{}: \textit{AnalisiDeiRequisiti\_v3.0.0};
\end{itemize}

\subsubsection{Informativi}
\begin{itemize}
    \item \textbf{Specifica HTML5} \url{https://www.w3.org/TR/html5/};
    \item \textbf{Specifica CSS3} \url{https://www.w3.org/TR/css3-roadmap/};
    \item \textbf{Documentazione Node.js} \url{https://nodejs.org/en/docs/};
    \item \textbf{Documentazione Express} \url{http://expressjs.com/en/guide/routing.html};
    \item \textbf{Documentazione MongoDB} \url{https://docs.mongodb.org/manual/?_ga=1.2705776.192504053.1456951655};
    \item \textbf{Documentazione Mongoose} \url{http://mongoosejs.com/docs/guide.html};
    \item \textbf{Documentazione Angularjs} \url{https://docs.angularjs.org/api};
    \item \textbf{Documentazione Bootstrap} \url{http://getbootstrap.com/css/}.
\end{itemize}

\newpage

\section{Tecnologie}\label{tecnologie}
In questa sezione verranno descritte le tecnologie che il gruppo ha deciso di utilizzare per lo sviluppo dell'applicazione \prjL{}, alcune delle quali sono state consigliate dal \mgls{proponente}.

\subsection{Linguaggi}
\subsubsection{HTML5}\label{html}
L’\mgls{html5} è un linguaggio di \mgls{markup} per strutturare pagine web. Verrà utilizzato per la realizzazione dell’interfaccia grafica Web dell’applicativo. \mgls{html5} è diventato standard \mgls{w3c} nell’ottobre 2014 ed è ben supportato dai \mgls{browser} moderni. I vantaggi principali del linguaggio sono:

\begin{itemize}
	\item permette di definire in maniera semplice la struttura delle pagine web;
	\item permette una maggiore semantica della pagina web, garantendo così una migliore indicizzazione da parte dei motori di ricerca.
\end{itemize}
Inoltre la scelta di \mgls{html5} è stata rafforzata dal fatto che non sono stati rilevati aspetti negativi nell'adozione di questo linguaggio per il progetto. 

\subsubsection{CSS3}\label{css}
CSS3 (Cascading Style Sheets) è il linguaggio che verrà utilizzato per l’aspetto grafico delle pagine web per l'applicazione qualora non bastassero i costrutti forniti dal \mgls{framework} Bootstrap ( \ref{bootstrap}).
Il gruppo anche in questo caso non ha trovato svantaggi nell'adottare CSS3 in quanto lo styling della pagina, per separation of concern, non dovrebbe essere fatta ne attraverso l'\mgls{html}, ne attraverso \mgls{javascript}.

\subsubsection{JavaScript}\label{javascript}
\mgls{javascript} è un linguaggio di \mgls{scripting} interpretato che consente ai \mgls{browser} di eseguire codice rendendo le pagine web dinamiche. Consente di realizzare prodotti \mgls{software} che eseguono sfruttando le capacità di calcolo fornite dai \mgls{browser} degli utenti e quindi, che non necessitano dell’intervento di elaborazione del \mgls{server}. \mgls{javascript} tuttavia introduce anche degli aspetti critici a cui il gruppo dovrà prestare particolare attenzione: come la mancanza di tipizzazione del linguaggio, che potrebbe indurre a commettere errori nel codice e rendere più difficile, oppure gli eventuali problemi di sicurezza per l'utente nel caso venisse eseguito del codice malevolo. I principali motivi della scelta di questo linguaggio sono:

\begin{itemize}
	\item velocità di risposta dell’applicazione complessivamente migliore, a causa dell’esecuzione locale;
	\item possibilità di rendere dinamiche le pagine web e di estenderne le funzionalità;
	\item permette di reagire ad eventi generati dall’interazione tra l’utente e la pagina.
\end{itemize}

\mgls{javascript} verrà utilizzato sia per la parte \mgls{client} che \mgls{server}. \mgls{javascript} verrà impiegato per tutte le funzionalità legate allo standard \mgls{html5} che non sono direttamente accessibili dal \mgls{framework} \mgls{angularjs}.

%\subsubsection{NoSql}\label{nosql}
%I \mgls{database} \mgls{nosql} nascono con l'idea di superare delle limitazioni implicite nei database \mgls{sql} e sono caratterizzati dal essere non relazionali, distribuiti, \mgls{open-source} e scalabili orizzontalmente. Molto frequentemente altre caratteristiche applicabili a questa tipologia di database sono: l'essere \mgls{schema-free} l'avere \mgls{api} semplici e la possibilità di avere una quantità di dati enormi al loro interno. Le sopracitate caratteristiche e la possibilità di cimentarsi con una tecnologia nuova per il gruppo hanno ci hanno indirizzato verso la scelta di questo tipo di database. 

\subsection{Frameworks}

\subsubsection{Node.js}\label{node.js}
\mgls{node.js} è un \mgls{framework} \mgls{open-source} per lo sviluppo di applicazioni Web server-side. Anche se \mgls{node.js} non è un \mgls{framework} \mgls{javascript} molti dei suoi moduli base  sono scritti in \mgls{javascript}, e gli sviluppatori possono facilmente scriverne di nuovi. \mgls{node.js} ha un architettura di tipo \mgls{event-driven} capace di chiamate \mgls{i/o} asincrone, il che lo rende particolarmente adatto per lo sviluppo di server Web. Queste scelte di design nel linguaggio di ottimizzare la capacità e la scalabilità delle applicazioni Web con molte operazioni di \mgls{i/o}.
Le principali caratteristiche che hanno fatto propendere il gruppo per \mgls{node.js} sono quindi:

\begin{itemize}
	\item \textbf{Approccio asincrono:} in quanto permette di accedere alle risorse del sistema operativo in modalità \mgls{event-driven} e non sfruttando il classico modello basato su processi o \mgls{thread} concorrenti utilizzato dai classici web server. Ciò garantisce una maggiore efficienza in termini di prestazioni, poiché durante le attese il runtime può gestire qualcos’altro in maniera asincrona
	\item \textbf{Architettura modulare:} lavorando con \mgls{node.js} è molto facile organizzare il lavoro in librerie, importare i \mgls{moduli} e combinarli fra loro. Questo è reso molto comodo attraverso il \mgls{node package manager} (npm) attraverso il quale lo sviluppatore può contribuire e
	accedere ai \mgls{package} messi a disposizione dalla community.
	Le applicazioni \mgls{node.js} vengono eseguite su un singolo \mgls{thread}, sebbene \mgls{node.js} utilizzi un modello \mgls{multi-thread} per la gestione degli eventi legati a file e connessioni di rete
\end{itemize}
Tuttavia bisogna tenere in considerazione che questo \mgls{framework} presenta anche degli aspetti potenzialmente critici, quali:
\begin{itemize}
	\item La relativa immaturità, in quanto anche se la maggior parte delle librerie fondamentali hanno raggiunto la stabilità, l'ecosistema in generale non ha raggiunto ancora un livello ottimo di maturità. Inoltre la facilità di pubblicazione dei propri pacchetti ed il modo in cui il \mgls{node package manager} è strutturato rende difficile il fidarsi degli stessi;
	\item L'utilizzo di codice \mgls{javascript} che comporta le problematiche citate introdotte dal linguaggio nella sezione \ref{javascript}.
\end{itemize}

\subsubsection{AngularJS}\label{angularjs}
\mgls{angularjs} è un \mgls{framework} \mgls{javascript} \mgls{open-source}  inspirato al pattern \mgls{mvc} patrocinato da \mgls{google}. Uno dei vantaggi più grandi che caratterizzano questo \mgls{framework} è la possibilità di integrare e utilizzare molte funzioni utilizzando quasi esclusivamente l’\mgls{html} grazie all’approccio dichiarativo, permettendo di estenderne la sintassi per esprimere le componenti dell’applicazione in maniera chiara e succinta. Le caratteristiche principali che caratterizzano questo \mgls{framework} sono:

\begin{itemize}
	\item \textbf{Data Binding:} è un’ approccio automatico per aggiornare la \mgls{vista} ogni qualvolta il \mgls{model} cambia e viceversa. Aiuta lo sviluppo eliminando la manipolazione del \mgls{dom} allo sviluppatore
	\item \textbf{Dependency injection:} permette di descrivere in maniera dichiarativa quali sono le
	dipendenze che l’applicazione possiede, isolando i comportamenti e le responsabilità dei componenti garantendo un facile rimpiazzo di quest’ultimi. Questo meccanismo favorisce inoltre la testabilità del codice dell’applicazione	
\end{itemize}
I potenziali rischi rilevati nell'adottare questo \mgls{framework} a cui il gruppo dovrà porre particolare attenzione sono:
\begin{itemize}
	\item La curva di apprendimento del linguaggio è relativamente ripida, rendendo l'apprendimento delle funzionalità non base difficile;
	\item Gli \mglspl{scope} sono facili da usare ma effettuare debugging sugli stessi è complesso;
	\item L'avvento imminente della versione 2.0 di \mgls{angularjs} rischia introdurre modifiche notevoli alla logica \mgls{front-end} in caso di rinnovamento delle tecnologie.
\end{itemize}
\mgls{angularjs} verrà impiegato sia per la creazione dell’interfaccia grafica sia per la parte algoritmica del \mgls{front-end}.

\subsubsection{Bootstrap}\label{bootstrap}
\mgls{bootstrap} è un insieme di elementi grafici, scritti in \mgls{javascript} e \mgls{css3}, che viene utilizzato per dare all'applicazione una grafica moderna e \mgls{responsive}. Bootstrap è stato scelto in quanto risponde a molte esigenze del gruppo:

\begin{itemize}
	\item permette all’applicativo di essere \mgls{responsive} applicando facilmente delle regole già pronte;
	\item Le diverse componenti vengono già incorporate direttamente nel \mgls{framework} \mgls{angularjs};
	\item presenza di una vasta comunità a supporto;
	\item permette di gestire in modo automatico il \mgls{rendering} delle pagine dell'applicazione per svariati dispositivi (\mgls{smartphone}, tablet, PC).
\end{itemize}

I potenziali aspetti critici derivanti dall'uso di \mgls{bootstrap} sono:
\begin{itemize}
	\item Il codice \mgls{html} generato da \mgls{bootstrap} ha molti tags \texttt{<div>} e rischia di essere altamente annidato confondendo in questo modo la leggibilità del codice;
	\item \mgls{bootstrap} fa affidamento a classi specifiche assegnate agli elementi della pagina che servono per abilitare determinate funzionalità del \mgls{framework}, tuttavia questo viola uno dei precetti principali della costruzione delle pagine web, cioè che la presentazione debba essere indipendente dai dati.
\end{itemize}

\subsubsection{Express}\label{express}
\mgls{express} è un \mgls{framework} minimale che aiuta ad organizzale le applicazioni web create con \mgls{node.js} secondo l'architettura \mgls{mvc} sul lato server. \mgls{express} integra \mgls{node.js}, fornendo una migliore implementazione del sistema di \mgls{routing}, incrementando le funzioni di richiesta e risposta estendendole per una maggior flessibilità, integrando nuovi \mgls{middleware}, ed agevolando la realizzazione delle \mglspl{vista}. \mgls{express} aiuta l'utente a gestire le \mgls{route}, le \mgls{request} e le \mgls{view}.
Dato che \mgls{express} integra le funzionalità di \mgls{node.js} gli aspetti potenzialmente critici sono gli stessi elencati nella sezione \ref{node.js}.


\subsection{Librerie}\label{librery}
\subsubsection{Mongoose}\label{mongoose}
Per questo progetto è stato scelto di utilizzare \mgls{mongoose}, attualmente il più diffuso \mgls{odm}. Questa libreria permette di definire degli schemi per modellare i dati del database, imponendo una certa struttura per la creazione di nuovi \mgls{Document}. Inoltre, fornisce molti strumenti utili per la validazione dei dati, per la definizione di \mgls{query} e per il cast dei tipi predefiniti.
La documentazione di \mgls{mongoose} è ben fornita e descrive le \mgls{api} in maniera esaustiva, fornendo degli \mgls{snippet} del codice sorgente.
Non sono state trovati particolari aspetti critici introdotti dall'utilizzo di \mgls{mongoose}.

\subsection{Database}
\subsubsection{MongoDB}\label{mongodb}
%copiata dagli stakeholders
\mgls{mongodb} è un database \mgls{nosql} \mgls{open-source} scalabile e altamente performante di tipo \mgls{document-oriented}, in cui i dati sono archiviati sotto forma di documenti in stile \mgls{json} con schemi dinamici che \mgls{mongodb} chiama \mgls{bson}, secondo una struttura semplice e potente. I principali vantaggi derivati dal suo utilizzo sono:

\begin{itemize}
	\item \textbf{Alte performance:} non ci sono \mgls{join} che possono rallentare le operazioni di lettura o scrittura. L’indicizzazione include gli indici di chiave anche sui documenti innestati e sugli array, permettendo una rapida interrogazione al database
	\item \textbf{Affidabilità:} alto meccanismo di replicazione su server
	\item \textbf{Schemaless:} non esiste nessuno \mgls{schema}, è più flessibile e può essere facilmente trasposto in un modello ad oggetti
	\item \textbf{Parallelizzazione:} permette di processare parallelamente i dati (\mgls{mapreduce})
	\item \textbf{Flessibilità:} tipi di dato più flessibili
\end{itemize}

Altre funzionalità comprendono la possibilità di creare delle \mgls{query} ad hoc, l’Auto-Sharding, ovvero la capacità di scalare orizzontalmente e di aggiungere nuove macchine al database operativo. Inoltre, \mgls{mongodb} supporta la definizione di collection con una dimensione fissata. Questo particolare tipo di collection mantiene l’ordine di inserimento e, una volta raggiunta la dimensione massima prefissata, si comporta come una lista circolare.

Tuttavia l'utilizzo di \mgls{mongodb} introduce alcuni aspetti potenzialmente critici:
\begin{itemize}
	\item Su \mgls{mongodb} non esiste la possibilità di effettuare \mgls{join} per questa ragione c'è il rischio di aumentare il numero di \mgls{query} da effettuare per ottenere i dati desiderati;
	\item \mgls{mongodb} non è transazionale quindi non assicura l'integrità dei dati, quindi per l'inserimento e la modifica dei dati bisogna controllare manualmente l'integrità dei dati;
	\item Quando vengono effettuate operazioni di scrittura sul database, questo imposta un blocco sulle operazioni di scritture e lettura sull'intero database. 
\end{itemize}

Il gruppo tuttavia ha ritenuto che gli aspetti positivi superassero di molto gli aspetti negativi e che l'utilizzo del \mgls{mean stack} completo sarebbe stato più coerente e documentato invece di scegliere un database \mgls{sql}.

\newpage
\section{Standard di progetto}

% Ciò che segue è da aggiungere nel periodo di codifica
% \subsection{Documentazione del codice}
% Gli standard relativi alla documentazione del codice sono specificati 
% nelle \textit{\NdP\_v3.0.0}.

% Ciò che segue è da aggiungere nel periodo di codifica
% \subsection{Documentazione del codice}
% Gli standard relativi alla documentazione del codice sono specificati 
% nelle \textit{\NdP\_v3.0.0}.

\subsection{Denominazione di entità e relazioni}
Entità e relazioni devono avere nomi chiari e concisi. È preferibile utilizzare sostantivi per le entità e verbi per le relazioni. Per ulteriori informazioni si vedano le \textit{\NdP\_v2.0.0}.

\subsection{Strumenti di lavoro}
Gli strumenti da adottare e le procedure da seguire per utilizzarli correttamente durante la realizzazione  del prodotto software sono definiti nelle \textit{\NdP\_v2.0.0}.

\newpage

% Definizione api REST
\section{API REST}
\input{../tex/definizioneDiProdotto/apiRest.tex}

\newpage
%Specifica componenti server
\input{../tex/definizioneDiProdotto/backEnd.tex}

\newpage

%Specifica componenti client
\input{../tex/definizioneDiProdotto/frontEnd.tex}

\newpage
\section{Design pattern}
Un \mgls{design pattern} descrive problemi che si presentano frequentemente nell'ambiente informatico, specificando relative soluzioni. La conoscenza dei \mgls{design pattern} facilita l’attività di progettazione, favorendo la riusabilità del codice e portando molteplici benefici in termini di manutenibilità. Possiamo suddividere i \mgls{design pattern} in quattro categorie:

\begin{itemize}
	\item \textbf{Design pattern architetturali:} che esprimono schemi di base per impostare l’organizzazione strutturale di un sistema software
	\item \textbf{Design pattern creazionali:} che forniscono un’astrazione del processo di istanziazione degli oggetti;
	\item \textbf{Design pattern strutturali:} che si occupano delle modalità di composizione di classi e oggetti per formare strutture complesse
	\item \textbf{Design pattern comportamentali:} che si occupano di algoritmi e dell’assegnamento di responsabilità tra oggetti collaboranti
\end{itemize}

\subsection{Design pattern architetturali}
\subsubsection{MVC}
\paragraph{Scopo}
Questo pattern è utilizzato per separare le responsabilità dell’applicazione a diversi componenti e permettere di fare una chiara divisione presentazione, struttura dei dati e operazioni su di essi.

\paragraph{Utilizzo}
Nel front-end viene utilizzato questo \mgls{design pattern} per dividere la presentazione dei dati dalla logica dell'applicazione e la logica di business. I vari componenti sono identificati nelle seguenti classi:

\begin{itemize}
	\item il package \texttt{client::model} è la business logic che gestisce i dati;
	\item il package \texttt{client::view} è la presentation logic che costruisce le pagine da visualizzare;
	\item il package \texttt{client::controller} è l'application logic.
\end{itemize}

\subsubsection{Middleware}
\paragraph{Scopo}
Si è scelto di utilizzare questo \mgls{design pattern} per fornire un intermediario tra i vari componenti software dell’applicazione in modo da semplificare notevolmente la loro connessione e collaborazione. Questo pattern in generale è molto utile nello sviluppo e nella gestione di sistemi distribuiti complessi, e nel nostro caso si adatta bene alla gestione di richieste \mgls{rest}.
\paragraph{Utilizzo}
Viene utilizzato dal framework \mgls{express} per fornire una libreria di funzioni comuni. Definisce una serie di livelli (o funzioni) per gestire le varie richieste dell’applicazione e richiamare i rispettivi handler. Tutti i componenti del middleware sono collegati l’uno con l’altro e ricevono a turno una richiesta in ingresso, finché uno di questi non decide di partire con l’elaborazione per poi chiamare la funzione \texttt{next}. Come si può notare è molto legato a Chain of Responsibility, che verrà descritto in seguito. Nella progettazione architetturale è utilizzato nel package \texttt{server::middleware}.

\subsection{Design pattern creazionali}

\subsubsection{Singleton}
\paragraph{Scopo}
Viene utilizzato per le classi che devono avere un’unica istanza, accessibile globalmente, durante l’esecuzione dell’applicazione.
\paragraph{Utilizzo}
Ogni modulo di \mgls{node.js} è nativamente un singleton, perché viene caricato alla prima chiamata \texttt{require} e poi tutti gli utilizzi successivi riferiscono sempre alla stessa istanza del modulo.

\subsection{Design pattern strutturali}

\subsubsection{Facade}
\paragraph{Scopo}
Viene utilizzato per rendere visibili solamente alcune componenti agli altri moduli ed avere un unico punto di accesso semplificato a un sottosistema fornendo un’interfaccia di alto livello e minimizzando dunque le comunicazioni e le dipendenze.

\paragraph{Utilizzo}
Viene utilizzato all’interno della classe \texttt{server::middleware::Loader}, la quale utilizza Facade per nascondere l’esistenza di tutti i middleware all'esterno. In questo modo le richieste vengono delegate agli oggetti appropriati senza che la classe cliente conosca le classi del sottosistema. Sarà il Facade che si occuperà di trasferire la comunicazione all’oggetto appropriato.

\subsection{Design Pattern Comportamentali}
\subsubsection{Chain of Responsibility}

\paragraph{Scopo}
Viene utilizzato per far sì che un oggetto a cui viene effettuata una richiesta possa completare le richieste di più oggetti. In questo modo si evita l’accoppiamento fra il mittente di una richiesta e il destinatario. Tutti gli oggetti destinatari della richiesta sono concatenati tra di loro. Ogni nodo della catena se può esaudire la richiesta la effettua, altrimenti delega l’onere al nodo successivo. La catena viene attraversata finché un nodo non può eseguire l’ordine del mittente.

\paragraph{Utilizzo}
\mgls{express} usa chain of responsibility per la gestione dei middleware e del routing. Come già accennato è particolarmente legato al pattern Middleware. Viene utilizzato nella nostra architettura all’interno del package \texttt{server::middleware}. La classe \texttt{server::middleware::Router} gestisce la richiesta scorrendo tutta la lista delle sottoclassi e richiamando il metodo \texttt{next} finché una di queste non può soddisfarla. Nel gergo del framework Express i middleware corrispondono agli oggetti ConcreteHandler del design pattern. Sebbene il comportamento e lo scopo sia quasi identico, l’implementazione di Express presenta alcune differenze:

\begin{itemize}
	\item I middleware di Express possono essere classi con un metodo \texttt{handle} o semplici funzioni, in pieno accordo con lo stile funzionale utilizzato dalla grande maggioranza delle librerie e delle applicazioni scritte in \mgls{node.js}. Nel progetto sarà utilizzata principalmente la seconda versione.
	\item Il \mgls{design pattern} prevede che l’oggetto \texttt{Handler} abbia un riferimento \texttt{successor} all’\texttt{Handler} successivo. \mgls{express} invece passa al metodo di esecuzione del middleware una callback. Il middleware, eseguendo la callback, passa nuovamente il controllo all’oggetto del server di \mgls{express} il quale passerà il controllo al successivo middleware.
	\item \mgls{express} divide i middleware in due gruppi: i middleware standard e i middleware di gestione degli errori, si distinguono per il numero di parametri che possono gestire (3 e 4, rispettivamente). Ogni middleware può decidere se passare il controllo al prossimo middleware standard o se passare il controllo al prossimo middleware di gestione degli errori (passandogli anche l’errore da gestire). Questa funzionalità serve per permettere la gestione di errori senza utilizzare i costrutti \texttt{try-catch}, tipici dei linguaggi imperativi ma inefficaci quando si utilizza lo stile di programmazione asincrono.
	\item Ogni middleware di \mgls{express} deve essere invocato con i seguenti parametri: l’eventuale errore da gestire (se è un middleware di gestione degli errori), l’oggetto della richiesta, l’oggetto della risposta, la callback da utilizzare per passare il controllo al successivo middleware. L’ordine è rilevante.
\end{itemize}

\newpage

\section{Diagrammi di sequenza}
Qui riportati alcuni diagrammi di sequenza per facilitare la comprensione della catena delle chiamate durante il lavoro in fase di codifica.

\subsection{Server}
Vengono di seguito presentati i diagrammi di sequenza di alcune delle operazioni più significative lato \mgls{server}.

\subsubsection{Login}
Di seguito viene presentato il diagramma di sequenza per l'accesso da parte di un ospite. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio. Tutte le richieste che arrivano al server passano per questo oggetto, il quale le instrada correttamente secondo il \mgls{design pattern} Chain of Responsibility
	\item \textbf{sessionService:} è l'oggetto che si occupa di controllare che le credenziali di accesso siano corrette e di eseguire l'accesso da parte dell'utente creando la sessione corrispondente
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto Viene invocato nel caso in cui le credenziali di accesso non siano corrette
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/loginServer.png}
		\caption{Diagramma sequenza - Login Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Registrazione}
Di seguito viene presentato il diagramma di sequenza del flusso per la registrazione di un utente presso il sistema. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio	
	\item \textbf{userService:}  è l'oggetto che si occupa di aggiungere le informazioni di un nuovo utente nel database del sistema
	\item \textbf{userCheck:} è l'oggetto che si occupa di controllare che le informazioni inserite dal nuovo utente siano corrette
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto Viene invocato nel caso in cui la richiesta non sia corretta, per esempio password troppo corta o username troppo corto
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/registrazioneServer.png}
		\caption{Diagramma sequenza - Registrazione Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Inserisci Domanda}
Di seguito viene presentato il diagramma di sequenza per l'inserimento di una domanda da parte di un docente, o utente di grado superiore. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso bisogna che l'utente sia almeno un docente
	\item \textbf{questionService:} è l'oggetto che si occupa di effettuare le modifiche nel database per l'aggiunta della domanda
	\item \textbf{questionCheck:} è l'oggetto che si occupa di controllare che gli attributi di una domanda siano consistenti
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto. Viene invocato nel caso in cui la richiesta non sia corretta, per esempio il QML non valido
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/inserisciDomandaServer.png}
		\caption{Diagramma sequenza - Inserisci Domanda Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Inserisci Questionario}
Di seguito viene presentato il diagramma di sequenza per l'inserimento di un questionario da parte di un docente, o utente di grado superiore. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso bisogna che l'utente sia almeno un docente
	\item \textbf{questionnaireService:} è l'oggetto che si occupa di effettuare le modifiche nel database per l'aggiunta del questionario
	\item \textbf{questionnaireCheck:} è l'oggetto che si occupa di controllare che gli attributi di un questionario siano consistenti
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto. Viene invocato nel caso in cui la richiesta non sia corretta, se mancano il titolo, gli argomenti o le domande
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/inserisciQuestionarioServer.png}
		\caption{Diagramma sequenza - Inserisci Questionario Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Visualizzazione Questionario}
Di seguito viene presentato il diagramma di sequenza per ottenere i dati di un questionario da visualizzare da parte del client. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’\mgls{uri} ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso verifica che l'utente sia loggato
	\item \textbf{questionnaireService:} è l'oggetto che si occupa di reperire i dati del questionario da restituire
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto. Viene invocato nel caso in cui la richiesta non sia corretta, per esempio quando il questionario selezionato non esiste
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/getQuestionnareDaEseguireServer.png}
		\caption{Diagramma sequenza - Visualizzazione questionario Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Modifica Domanda}
Di seguito viene presentato il diagramma di sequenza del flusso per la modifica di una domanda da parte del docente, o utente di grado superiore, che l' ha creata. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso verifica che l'utente sia almeno un docente
	\item \textbf{questionService:} è l'oggetto che si occupa di effettuare le modifiche nel database per la modifica della domanda
	\item \textbf{questionCheck:} è l'oggetto che si occupa di controllare che gli attributi di una domanda siano consistenti
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto. Viene invocato nel caso in cui la richiesta non sia corretta, per esempio quando la domanda modificata non ha il QML valido
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/modificaDomandaServer.png}
		\caption{Diagramma sequenza - Modifica Domanda Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Modifica Questionario}
Di seguito viene presentato il diagramma di sequenza del flusso per la modifica di un questionario da parte del docente, o utente di grado superiore, che lo ha creato. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso verifica che l'utente sia almeno un docente
	\item \textbf{questionnaireService:} è l'oggetto che si occupa di effettuare le modifiche nel database per la modifica del questionario
	\item \textbf{questionnaireCheck:} è l'oggetto che si occupa di controllare che gli attributi di un questionario siano consistenti
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto. Viene invocato nel caso in cui la richiesta non sia corretta, per esempio quando il nuovo questionario non presenta titolo, argomenti o domande
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/modificaQuestionarioServer.png}
		\caption{Diagramma sequenza - Modifica Questionario Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Rimozione Domanda}
Di seguito viene presentato il diagramma di sequenza del flusso per la rimozione di una domanda da parte del docente, o utente di grado superiore, che la ha creata. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso si verifica che l'utente sia almeno un docente
	\item \textbf{questionService:} è l'oggetto che si occupa di effettuare le modifiche nel database per la rimozione della domanda
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto. Viene invocato nel caso in cui la richiesta non sia corretta, per esempio quando il questionario da eliminare non esiste
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/rimozioneDomandaServer.png}
		\caption{Diagramma sequenza - Rimozione Domanda Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Rimozione Questionario}
Di seguito viene presentato il diagramma di sequenza del flusso per la rimozione di una questionario da parte del docente, o utente di grado superiore, che lo ha creato. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta, in questo caso verifica l'utente sia almeno un docente
	\item \textbf{questionnaireService:} è l'oggetto che si occupa di effettuare le modifiche nel database per la rimozione del questionario
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/rimozioneQuestionarioServer.png}
		\caption{Diagramma sequenza - Rimozione Questionario Server}
	\end{figure}
\end{center}

\subsection{Client}

Vengono di seguito presentati i diagrammi di sequenza di alcune delle operazioni più significative lato \mgls{client}, ovvero il front-end dell'applicazione.

\subsubsection{Login}
Di seguito viene presentato il diagramma di sequenza per l'accesso da parte di un ospite dal punto di vista del client. L'utente inserisce le credenziali e chiama submit() sul controller il quale si occuperà di richiamare i servizi adatti per istanziare una nuova sessione. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Ospite:} l'utente non autenticato che ha intenzione di effettuare l'accesso
	\item \textbf{LogInView:} è la pagina che mostra il form per accedere
	\item \textbf{LogInController:} è il \mgls{controller} dell'applicazione che si occupa di controllare i dati immessi dall'utente e chiamare il servizio per effettuare il login
	\item \textbf{sessionService:} è l'oggetto che invia la richiesta di login al server
	\item \textbf{userService:} è l'oggetto che si occupa di comunicare con il server per ottenere i dati dell'utente autenticato
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/loginClient.png}
		\caption{Diagramma sequenza - Login Client}
	\end{figure}
\end{center}

\newpage
\subsubsection{Cambio Informazioni}
Di seguito viene presentato il diagramma di sequenza del flusso per il cambio di nome utente e nome completo da parte di un utente autenticato presso il sistema. L'utente inserisce i dati modificati e li invia al controller il quale chiama i servizi adatti per modificare il profilo personale. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Studente:} l'utente autenticato con ruolo di studente o superiore che ha intenzione di cambiare le informazioni personali
	\item \textbf{userView:} è la pagina che mostra i dati dell'utente connesso al sistema
	\item \textbf{userController:} è il \mgls{controller} dell'applicazione che si occupa delle modifiche dell'utente, dal cambio di informazioni personali al cambio di password
	\item \textbf{check:} è l'oggetto che controlla se la password, l'username o titolo rispettano il formato scelto	
	\item \textbf{userService:} è l'oggetto che si occupa di comunicare con il server per apportare le modifiche
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/cambioInfoClient.png}
		\caption{Diagramma sequenza - Cambio Informazioni Client}
	\end{figure}
\end{center}

\newpage
\subsubsection{Cambio Password}
Di seguito viene presentato il diagramma di sequenza per il cambio della password da parte dell'utente connesso al sistema. L'utente inserisce la nuova password e la invia al controller il quale chiama i servizi adatti per modificare il profilo personale.Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Studente:}  l'utente autenticato con ruolo di studente o superiore che ha intenzione di cambiare la password
	\item \textbf{userView:} è la pagina che mostra i dati dell'utente connesso al sistema
	\item \textbf{userController:} è il \mgls{controller} dell'applicazione che si occupa delle modifiche dell'utente, dal cambio di informazioni personali al cambio di password
	\item \textbf{userService:} è l'oggetto che si occupa di comunicare con il server per apportare le modifiche
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/cambioPasswordClient.png}
		\caption{Diagramma sequenza - Cambio Password Client}
	\end{figure}
\end{center}

\newpage
\subsubsection{Inserisci Questionario}
Di seguito viene presentato il diagramma di sequenza per l'inserimento di un questionario da parte di un utente con ruolo docente o superiore. L'utente inserisce il titolo, gli argomenti e seleziona le domande da inserire, poi li passa al controller che chiama li servizio per aggiungere un questionario. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Docente:}	 l'utente autenticato con ruolo di docente o superiore che ha intenzione di inserire il questionario
	\item \textbf{manageQuestionnairesView:} è la pagina dell'applicazione che mostra la lista di tutti i questionari e permette la modifica o eliminazione di questionari esistenti o aggiunta di nuovi questionari
	\item \textbf{manageQuestionnairesController:} è il \mgls{controller} che permette di visualizzare e modificare i questionari della view corrispondente
	\item \textbf{manipulateQuestionnaireView:} rappresenta la pagina per la modifica o creazione di un singolo questionario
	\item \textbf{manipulateQuestionnaireController:} è il \mgls{controller} che si occupa di gestire le richieste dalla view corrispondente per la gestione o creazione di un singolo questionario
	\item \textbf{questionnaireService:} è l'oggetto che si occupa della comunicazione con il server per completare l'operazione di modifica o creazione del questionario
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/inserisciQuestionarioClient.png}
		\caption{Diagramma sequenza - Inserisci Questionario Client}
	\end{figure}
\end{center}

\newpage
\subsubsection{Esecuzione Questionario}
Di seguito viene presentato il diagramma di sequenza per l'inserimento di un questionario da parte di un utente con ruolo docente o superiore. Lo studente può rispondere alla domanda corrente, andare a quella precedente o quella successiva, poi, cliccando sulla funzionalità correggi, il controller chiama i servizi per verificare che tutte le domande abbiano una risposta e, in caso positivo, restituire il risultato del questionario. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Studente:}	 l'utente autenticato con ruolo di studente o superiore che ha intenzione di eseguire il questionario
	\item \textbf{executeQuestionnaireView:} rappresenta la pagina di visualizzazione del questionario in esecuzione
	\item \textbf{executeQuestionView:} rappresenta la pagina di visualizzazione di una singola domanda all'interno del questionario corrente
	\item \textbf{executeQuestionnaireController:} oggetto che gestisce la visualizzazione sequenziale delle domande da compilare per il questionario in esecuzione
	\item \textbf{executeQuestionController:} oggetto che gestisce la visualizzazione di una singola domanda all'interno del questionario in esecuzione
	\item \textbf{currentQuestionnaire:} oggetto che rappresenta i dati del questionario in esecuzione
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/executeQuestionnaireClient.png}
		\caption{Diagramma sequenza - Esecuzione questionario Client}
	\end{figure}
\end{center}

\newpage
\subsubsection{Rimozione domanda}
Di seguito viene presentato il diagramma di sequenza del flusso per la rimozione di una domanda da parte del docente che la ha creata. L'utente seleziona la domanda da rimuovere e la rimuove, se questa non è presente in nessun questionario l'operazione va a buon fine, altrimenti viene visualizzato un messaggio di errore e la domanda non viene eliminata. Gli oggetti ed attori attivi durante questa operazione sono:

\begin{itemize}
	\item \textbf{router:} è l'oggetto che si occupa di smistare la richiesta in base all’URI ricevuto e ad invocare l’opportuno servizio
	\item \textbf{authorization:} è l'oggetto che si occupa di verificare i permessi dell'utente per ogni richiesta	
	\item \textbf{questionService:} è l'oggetto che si occupa di effettuare le modifiche nel database per l'aggiunta, rimozione e modifica di domande
	\item \textbf{errorHandler:} è il \mgls{middleware} che viene invocato verso la fine della richiesta che si occupa di trasformare eventuali errori nel formato \mgls{json} richiesto
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/rimozioneQuestionarioClient.png}
		\caption{Diagramma sequenza - Rimozione domanda Server}
	\end{figure}
\end{center}

\newpage
\subsubsection{Modifica Questionario}
Di seguito viene presentato il diagramma di sequenza per la modifica di un singolo questionario da parte di un utente con ruolo di docente o superiore. Quando l'utente seleziona la funzionalità nella view, il controller semplicemente richiama il servizio per promuovere o degradare un certo utente. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Docente:}	 l'utente autenticato con ruolo di docente o superiore che ha intenzione di inserire il questionario
	\item \textbf{manageQuestionnairesView:} è la pagina dell'applicazione che mostra la lista di tutti i questionari e permette la modifica o eliminazione di questionari esistenti o aggiunta di nuovi questionari
	\item \textbf{manageQuestionnairesController:} è il \mgls{controller} che permette di visualizzare e modificare i questionari della view corrispondente
	\item \textbf{manipulateQuestionnaireView:} rappresenta la pagina per la modifica o creazione di un singolo questionario
	\item \textbf{manipulateQuestionnaireController:} è il \mgls{controller} che si occupa di gestire le richieste dalla view corrispondente per la gestione o creazione di un singolo questionario
	\item \textbf{questionnaireService:} è l'oggetto che si occupa della comunicazione con il server per completare l'operazione di modifica o creazione del questionario
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/modificaQuestionarioClient.png}
		\caption{Diagramma sequenza - Modifica Questionario Client}
	\end{figure}
\end{center}

\newpage
\subsubsection{Rimozione Questionario}
Di seguito viene presentato il diagramma di sequenza per la rimozione di un questionario da parte di un docente. Il docente seleziona la domanda da rimuovere e il controller provvede a chiamare il servizio per effettuare l'operazione di rimozione attraverso la relativa API. Gli oggetti e attori attivi durante questa interazione sono:

\begin{itemize}
	\item \textbf{Docente:}	 l'utente autenticato con ruolo di docente o superiore che ha intenzione di inserire il questionario
	\item \textbf{manageQuestionnairesView:} è la pagina dell'applicazione che mostra la lista di tutti i questionari e permette la modifica o eliminazione di questionari esistenti o aggiunta di nuovi questionari
	\item \textbf{manageQuestionnairesController:} è il \mgls{controller} che permette di visualizzare, modificare o eliminare i questionari della view corrispondente
	\item \textbf{questionnaireService:} è l'oggetto che si occupa della comunicazione con il server per completare l'operazione di modifica, creazione o eliminazione del questionario
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\myheight, angle=90]{../img/diagrammiSequenza/rimozioneQuestionarioClient.png}
		\caption{Diagramma sequenza - Rimozione Questionario Client}
	\end{figure}
\end{center}

\newpage
\appendix

\section{Descrizione Design Pattern}
\subsection{Design Pattern Architetturali}
\subsubsection{MVC}
Model-View-Controller (\mgls{mvc}) è un \mgls{design pattern} per l’implementazione di interfacce utente. Esso divide un’applicazione \mgls{software} in tre parti interconnesse, in modo da separare nettamente la rappresentazione interna dei dati dal modo in cui essa viene presentata all’utente. Il \mgls{model} è il modulo che contiene i dati. Una \mgls{view} può essere qualsiasi output dell’informazione, come ad esempio un testo o un diagramma. Si possono avere molteplici \mgls{view} della stessa informazione. La terza parte, il \mgls{controller}, si occupa di accettare degli input e di convertirli in comandi per il \mgls{model} o per la \mgls{view}.\\
Oltre a dividere l’applicazione in queste tre componenti, \mgls{mvc} si occupa anche di definire le interazioni tra esse:
\begin{itemize}
	\item Un \mgls{controller} gestisce gli input che vengono generati dalla \mgls{view} e può inviare comandi al \mgls{model} per aggiornare il suo stato. Inoltre seleziona quale view deve essere eseguita e visualizzata;
	\item Un \mgls{model} quando cambia il suo stato interno notifica le \mgls{view} associate. Questo permette alle \mgls{view} di cambiare la loro presentazione;
	\item Una \mgls{view} riceve aggiornamenti dal \mgls{model} per cambiare il suo stato e notifica al \mgls{controller} i comandi dell'utente.
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\textwidth]{../img/mvcStarware.png}
		\caption{Esempio dell' applicazione di MVC in Quizzipedia}
	\end{figure}
\end{center}

Sebbene inizialmente sviluppata per applicazioni \mgls{desktop}, \mgls{mvc} è stato usato moltissimo come architettura per le Web application in tutti i principali linguaggi di programmazione. Moltissimi \mgls{framework} commerciali e non sono stati progettati utilizzando questo \mgls{design pattern}.

\subsubsection{Middleware}
Il Middleware è uno strato \mgls{software} che si interpone tra l’applicazione \mgls{software} e uno strato di servizi per semplificarne le comunicazioni e la gestione di input/output. Viene solitamente utilizzato in applicazioni distribuite e facilita l’interoperabilità, fornendo servizi che permettono la comunicazione tra applicazioni di sistemi operativi diversi. Può accedere che il Middleware fornisca dei servizi abitualmente attribuibili a un sistema operativo. I servizi Middleware forniscono un set di interfacce che permetto a un’applicazione di:
\begin{itemize}
	\item Localizzare facilmente applicazioni o servizi in una rete;
	\item Filtrare dati per renderli user-friendly oppure anonimizzarli per renderli pubblicabili, proteggendone la privacy;
	\item Essere indipendente dai servizi di rete;
	\item Essere affidabile e sempre disponibile;
	\item Aggiungere attributi complementari.
\end{itemize}
Si tratta quindi di funzionalità leggermente più specializzate da quelle normalmente offerte da un sistema operativo. L’avvento del web ha avuto una forte ripercussione sulla diffusione dei \mgls{software} di Middleware. Essi hanno infatti permesso l’accesso sicuro da remoto a \mgls{database} locali. I tipi di Middleware sono:
\begin{itemize}
	\item \textbf{Message-Oriented Middleware (MOM):} sono Middleware dove le notifiche degli	eventi vengono spedite come messaggi tra sistemi o componenti. I messaggi inviati al
	\mgls{client} vengono memorizzati fintanto che non vengono gestiti, nel frattempo il \mgls{client} può	svolgere altro lavoro 
	\item \textbf{Enterprise messaging system:} è un tipo di Middleware che facilita il passaggio di messaggi tra sistemi diversi o componenti in formato standard, spesso utilizzando servizi web o \mgls{xml}
	\item \textbf{Message broker:} è parte dell'entreprise messaging system. Accoda, duplica, traduce e spedisce messaggi a sistemi o componenti diverse
	\item \textbf{Enterprise Service Bus:} è definito come qualche tipo di Middleware integrato che supporta sia MOM che dei servizi web
	\item \textbf{Intelligent Middleware:} gestisce il processamento in tempo reale di grandi volumi di segnali che trasforma in informazioni di business. Particolarmente adatto per architetture scalabili e distribuite
	\item \textbf{Content-Centric Middleware:} questo tipo di Middleware fornisce una semplice astrazione con la quale le applicazioni possono inoltrare richieste per contenuti univocamente identificati, senza occuparsi su come e dove vanno ottenuti
\end{itemize}

\subsection{Design Pattern Creazionali}
\subsubsection{Singleton}
Il Singleton è un \mgls{design pattern} creazionale che permette di avere un’unica istanza di una classe con un unico punto di accesso noto. Tale condizione è tipica di alcuni contesti e trova risvolti pratici in svariate applicazioni. Per permettere l’implementazione di questo pattern è sufficiente che la classe stessa si occupi di tracciare la propria istanziazione e bloccarla qualora sia già avvenuta almeno una volta. Il Singleton dovrebbe essere estensibile usando il \mgls{subclassing}. Il \mgls{client} può utilizzarne l’estensione senza quindi modificarne il codice.\\
L’utilizzo di questo \mgls{design pattern} comporta una serie di conseguenze:
\begin{itemize}
	\item accesso controllato alla singola istanza: poiché la classe Singleton incapsula la sua unica istanza, è in grado di controllare quando e come i \mgls{client} vi accedono;
	\item \mgls{namespace} pulito: l’utilizzo di questo pattern risulta migliore rispetto all’uso di variabili globali poiché scongiura l’inquinamento del \mgls{namespace} globale;
	\item permette raffinamenti di operazioni e rappresentazioni: il Singleton dovrebbe venire sempre esteso prima dell’utilizzo, che in termini pratici si traduce in un operazione banale. Questo può avvenire anche a runtime;
	\item eventualmente permette un numero variabile di istanze: questo pattern permette, se necessario, di avere istanze multiple mantenendo però il controllo sul numero;
	\item flessibilità: un modo per avere una funzionalità riconducibile al Singleton è quello di utilizzare le operazioni sulle classi, come per esempio la keyword static del C++, ma in questo modo è più difficile controllarne il design e permetterne più istanze. Inoltre nel linguaggio succitato le funzioni statiche non sono mai virtuali, rendendone impossibile l’utilizzo polimorfo alle sottoclassi che le ridefinisco.
\end{itemize}

%Non utilizzato per ora
%\subsubsection{Registry}
%Il Registry è simile ad un oggetto globale che gli altri oggetti usano per accedere a servizi e oggetti comuni. Quando si vuole recuperare un oggetto capita spesso di accedervi tramite un altro oggetto legato da un qualche tipo di associazione, ma in alcuni casi non è possibile conoscere a priori l’oggetto da cui partire, così vi è la necessità di avere un metodo di look-up accedibile tramite il Registry. Le interfacce del Registry possono essere metodi statici.

%Non utilizzato per ora
%\subsubsection{Factory method}
%Questo pattern definisce un’interfaccia per la creazione di un oggetto, lasciando alle sottoclassi la decisione sulla classe che deve essere istanziata. Consente inoltre di deferire l’istanziazione di una classe alle sottoclassi. Tra i suoi utilizzi ci sono i seguenti casi:
%\begin{itemize}
	%\item Quando una classe non è in grado di sapere in anticipo le classi degli oggetti che deve creare;
	%\item Quando una classe vuole che le sue sottoclassi scelgano gli oggetti da creare;
	%\item Quando le classi delegano la responsabilità a una o più classi di supporto e si vuole localizzare in un punto ben preciso la conoscenza di quale o quali classi di supporto vengano delegate.
%\end{itemize}

\subsection{Design Pattern Strutturali}
\subsubsection{Facade}
Questo pattern fornisce un’interfaccia unificata per un insieme di interfacce presenti in un sottosistema. Facade definisce un’interfaccia di alto livello che rende il sottosistema più semplice da utilizzare. Suddividere un sistema in sottosistemi aiuta a ridurne la complessità. Può essere utilizzato nei seguenti casi:
\begin{itemize}
	\item Quando si vuole fornire un’interfaccia semplice a un sottosistema complesso. La complessità dei sottosistemi tende ad aumentare con la loro evoluzione. Molti pattern, quando applicati, portano a un aumento nel numero di classi piccole. Ciò rende il sottosistema maggiormente riusabile e semplice da personalizzare, ma di utilizzo più difficile per i \mgls{client} che non richiedono alcuna personalizzazione. Un Facade può fornire una vista semplice di base su un sottosistema che si rivela essere sufficiente per la maggior parte dei \mgls{client}. Soltanto i \mgls{client} che richiedono una personalizzazione maggiore dovranno guardare dietro la facciata;
	\item Nei casi in cui sono molte le dipendenze fra i \mgls{client} e le classi che implementano un’astrazione. Introducendo un Facade si disaccoppia il sottosistema dai \mgls{client} e dagli altri sottosistemi, promuovendo quindi la portabilità e l’indipendenza di sottosistemi;
	\item Quando si vogliono organizzare i sottosistemi in una struttura a livelli. Un Facade può essere utilizzato per definire un punto di ingresso ad ogni livello. Nel caso in cui i sottosistemi non siano indipendenti e le dipendenze esistenti possano essere semplificate facendo comunicare tra loro i sottosistemi soltanto attraverso i rispettivi oggetti Facade.
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\textwidth]{../img/facadeStarware.png}
		\caption{Esempio dell' applicazione del pattern Facade in Quizzipedia}
	\end{figure}
\end{center}

\subsection{Design Pattern Comportamentali}
\subsubsection{Chain of Responsibility}
Il Chain of Responsibility è un pattern comportamentale che permette di separare i \mgls{sender} dai \mgls{receiver} delle richieste. La richiesta attraversa una catena di oggetti per essere intercettata solo quando raggiunge il proprio gestore. Viene utilizzato quando non è possibile determinare staticamente il \mgls{receiver} oppure l’insieme di oggetti gestori cambia dinamicamente a runtime. Le richieste vengono dette implicite poiché il \mgls{sender} non ha alcuna conoscenza sull’identità del ricevente. Per permettere alla richiesta di attraversare la catena e per rimanere implicita, ogni \mgls{receiver} condivide un interfaccia comune per gestire le richieste ed accedere al proprio successore. La gerarchia che vorrà inviare richieste dovrà avere una superclasse che dichiara un metodo handler generico. La specializzazione di tale metodo avviene tramite overriding nelle sottoclassi opportune.\\
L’utilizzo di questo pattern comporta una serie di conseguenze:
\begin{itemize}
	\item Ridotto accoppiamento: gli oggetti non sono a conoscenza di chi gestirà la richiesta ma sanno solo che verrà gestita in modo appropriato. Inoltre non bisognerà manutenere i riferimenti a tutti i possibili riceventi;
	\item Aggiunge flessibilità nell’assegnamento delle responsabilità degli oggetti: è possible distribuire le responsabilità tra gli oggetti a runtime modificandone la gerarchia. Staticamente è possibile usare il |\mgls{subclassing} per specializzare i gestori;
	\item Non c’è garanzia che la richiesta venga gestita, questo può avvenire quando la catena non è stata costruita in modo rigoroso.
\end{itemize}

\begin{center}
	\begin{figure}[H]
		\centering \includegraphics[max width=\textwidth]{../img/corStarware.png}
		\caption{Funzionamento del Chain of responsibility in Quizzipedia}
	\end{figure}
\end{center}

%Non utilizzato per ora
%\subsubsection{Strategy}
%Strategy ha come scopo quello di definire una famiglia di algoritmi, incapsularli e renderli intercambiabili. Permette agli algoritmi di variare indipendentemente dal client che ne fa uso. È opportuno usare il pattern strategy nei seguenti casi:
%\begin{itemize}
	%\item Molte classi correlate differiscono fra loro solo per il comportamento. Strategy fornisce un modo per configurare una classe con un comportamento scelto fra tanti;
	%\item Sono necessarie più varianti di un algoritmo. Per esempio, è possibile definire più algoritmi con bilanciamenti diversi fra occupazione in memoria, velocità di esecuzione, ecc. Possiamo usare il pattern Strategy quando queste varianti sono implementate sotto forma di gerarchia di classi di algoritmi;
	%\item Un algoritmo usa una struttura dati che non dovrebbe essere resa nota ai client. Il pattern strategy può essere usato per evitare di esporre strutture dati complesse e specifiche dell’algoritmo;
	%\item Una classe definisce molti comportamenti che compaiono all’interno di scelte condizionali multiple. Al posto di molte scelte condizionali si suggerisce di spostare i blocchi di codice correlati in una classe Strategy dedicata.
%\end{itemize}

%Non utilizzato per ora
%\subsubsection{Dependency Injection}
%Il Dependency Injection è un Design Pattern che permette la separazione del comportamento degli oggetti dalla loro dipendenze. Invece di istanziare le classi in modo diretto ogni componente riceve i riferimenti agli altri componenti necessari come parametri nel costruttore. Un utilizzo comune è quello con i plugin che vengono caricati dinamicamente. Gli elementi coinvolti sono:
%\begin{itemize}
	%\item Un dipendente consumatore;
	%\item Una dichiarazione delle dipendenze tra la componenti, definita come contratto di un interfaccia;
	%\item Un injector che crea istanze di classi che implementano una data dipendenza su richiesta.
%\end{itemize}
%Il dependent object dichiara da quali componenti dipende. L’injector decide quali classi soddisfano suoi requisiti e in caso affermativo gliele fornisce. Questa operazione può avvenire anche a runtime. Questo è un chiaro vantaggio poiché possono essere create dinamicamente diverse implementazioni di un componente software da passare allo stesso test. In questo modo il test può testare componenti diverse senza sapere che le loro implementazioni sono diverse. Lo scopo principale di questo pattern è quello di permettere una selezione a runtime su più implementazioni di una interfaccia dipendente. È particolarmente utile per fornire delle implementazioni di stub per componenti complesse, ma anche per gestire i plugin e per inizializzare servizi software. I test di unità comportano delle problematiche, poiché spesso richiedono la presenza di una parte di infrastruttura non ancora implementata. Il Dependency Injection semplifica il processo di testing per un istanza isolata. Poiché le componenti dichiarano le proprie dipendenze, un test può automaticamente istanziare le componenti necessarie.\\
%L’utilizzo di questo pattern comporta una serie di conseguenze:
%\begin{itemize}
	%\item Vi è una riduzione di Boilerplate code poiché il lavoro di set up delle dipendenze viene gestito da un componente dedicato;
	%\item Offre una certa flessibilità di configurazione perché diverse implementazione di un servizio posso essere usate senza essere ricompilate;
	%\item Facilita la scrittura di codice testabile;
	%\item Le dipendenze dichiarate sono black box, questo rende più difficile trovare gli errori al loro interno;
	%\item Le dipendenze non completamente implementate o errate generano errori a runtime e non a tempo di compilazione;
	%\item Rende il codice più difficile da manutenere;
	%\item L’injection a runtime di dipendenze va ad inficiare le prestazioni;
	%\item I benefici sono difficilmente commisurabili rispetto ai costi di implementazione.
%\end{itemize}
%Di seguito vengono elencati tre modi con cui un oggetto può ricevere un riferimento da un modulo esterno:
%\begin{itemize}
	%\item \textbf{Interface injection}: l’oggetto fornisce un interfaccia che gli utenti possono implementare in modo da ottenere a runtime le dipendenze;
	%\item \textbf{Setter injection}: il dependent module espone un metodo setter che il framework usa per iniettarvi le dipendenze;
	%\item \textbf{Constructor injection}: le dipendenze vengono fornite tramite il costruttore della classe.
%\end{itemize}

%Non lo usiamo per ora
%\subsubsection{Command}
%Il command pattern è uno dei Design Pattern che permette di isolare la porzione di codice che effettua un’azione (eventualmente molto complessa) dal codice che ne richiede l’esecuzione. L’azione è incapsulata nell’oggetto Command. L’obiettivo è rendere variabile l’azione del client senza però conoscere i dettagli dell’operazione stessa. Altro aspetto importante è che il destinatario della richiesta può non essere deciso staticamente all’atto dell’istanziazione del Command ma dev’essere ricavato a tempo di esecuzione. È possibile incapsulare un’azione in modo che questa sia atomica. È così possibile implementare un paradigma basato su transazioni in cui un insieme di operazioni è svolto in toto o per nulla.

\newpage

\section{Tracciamento}

\subsection{Requisiti - classe}
\input{../tex/definizioneDiProdotto/requisitiClassi.tex}

\newpage

\subsection{Classe - requisiti}
\input{../tex/definizioneDiProdotto/classiRequisiti.tex}

\end{document} 
